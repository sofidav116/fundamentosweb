package com.curso.android.module3.amiibo.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.curso.android.module3.amiibo.data.local.entity.AmiiboEntity
import com.curso.android.module3.amiibo.domain.error.AmiiboError
import com.curso.android.module3.amiibo.domain.error.ErrorType
import com.curso.android.module3.amiibo.repository.AmiiboRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

/**
 * ============================================================================
 * AMIIBO UISTATE - Estado de la UI (Sealed Interface)
 * ============================================================================
 *
 * UiState representa todos los posibles estados de la pantalla.
 * Usar sealed interface garantiza que manejemos TODOS los casos en la UI.
 *
 * PATR√ìN UISTATE:
 * ---------------
 * En lugar de tener m√∫ltiples variables separadas:
 * ```kotlin
 * // ‚ùå Antipatr√≥n
 * val isLoading: Boolean
 * val error: String?
 * val data: List<Amiibo>?
 * ```
 *
 * Usamos un solo estado que representa TODAS las posibilidades:
 * ```kotlin
 * // ‚úÖ Patr√≥n UiState
 * sealed interface UiState {
 *     object Loading : UiState
 *     data class Success(val data: List<Amiibo>) : UiState
 *     data class Error(val message: String) : UiState
 * }
 * ```
 *
 * BENEFICIOS:
 * -----------
 * 1. Type-safe: El compilador verifica que manejemos todos los casos
 * 2. Exclusividad: Solo puede estar en UN estado a la vez
 * 3. Claridad: El c√≥digo de UI es m√°s legible con when exhaustivo
 * 4. Testeable: F√°cil de verificar estados en tests
 *
 * SEALED INTERFACE VS SEALED CLASS:
 * ---------------------------------
 * - sealed interface: M√°s flexible, permite herencia m√∫ltiple
 * - sealed class: Puede tener constructor con par√°metros comunes
 * - En Kotlin moderno, sealed interface es preferido
 *
 * ============================================================================
 */
sealed interface AmiiboUiState {

    data object Loading : AmiiboUiState

    data class Success(
        val amiibos: List<AmiiboEntity>,
        val isRefreshing: Boolean = false
    ) : AmiiboUiState

    data class Error(
        val message: String,
        val errorType: ErrorType = ErrorType.UNKNOWN,
        val isRetryable: Boolean = true,
        val cachedAmiibos: List<AmiiboEntity> = emptyList()
    ) : AmiiboUiState
}

class AmiiboViewModel(
    private val repository: AmiiboRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow<AmiiboUiState>(AmiiboUiState.Loading)
    val uiState: StateFlow<AmiiboUiState> = _uiState.asStateFlow()

    private val _pageSize = MutableStateFlow(AmiiboRepository.DEFAULT_PAGE_SIZE)
    val pageSize: StateFlow<Int> = _pageSize.asStateFlow()

    private val _currentPage = MutableStateFlow(0)
    private val _loadedAmiibos = MutableStateFlow<List<AmiiboEntity>>(emptyList())

    private val _hasMorePages = MutableStateFlow(true)
    val hasMorePages: StateFlow<Boolean> = _hasMorePages.asStateFlow()

    private val _isLoadingMore = MutableStateFlow(false)
    val isLoadingMore: StateFlow<Boolean> = _isLoadingMore.asStateFlow()

    private val _paginationError = MutableStateFlow<String?>(null)
    val paginationError: StateFlow<String?> = _paginationError.asStateFlow()

    val pageSizeOptions: List<Int> = AmiiboRepository.PAGE_SIZE_OPTIONS

    private val amiibosFromDb: StateFlow<List<AmiiboEntity>> = repository
        .observeAmiibos()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5_000),
            initialValue = emptyList()
        )

    init {
        observeDatabaseChanges()
        refreshAmiibos()
    }

    private fun observeDatabaseChanges() {
        viewModelScope.launch {
            amiibosFromDb.collect { amiibos ->
                val currentState = _uiState.value
                if (amiibos.isNotEmpty()) {
                    _uiState.value = AmiiboUiState.Success(
                        amiibos = amiibos,
                        isRefreshing = currentState is AmiiboUiState.Success &&
                                (currentState as? AmiiboUiState.Success)?.isRefreshing == true
                    )
                }
            }
        }
    }

    fun setPageSize(newSize: Int) {
        if (newSize != _pageSize.value && newSize in pageSizeOptions) {
            _pageSize.value = newSize
            resetPagination()
            refreshAmiibos()   // ‚úÖ Correcci√≥n: loadFirstPage() eliminada
        }
    }

    private fun resetPagination() {
        _currentPage.value = 0
        _loadedAmiibos.value = emptyList()
        _hasMorePages.value = true
        _paginationError.value = null
    }

    fun loadNextPage() {
        if (_isLoadingMore.value || !_hasMorePages.value || _paginationError.value != null) return

        viewModelScope.launch {
            _isLoadingMore.value = true
            _paginationError.value = null

            try {
                val nextPage = _currentPage.value + 1
                val newItems = repository.getAmiibosPage(nextPage, _pageSize.value)

                if (newItems.isNotEmpty()) {
                    _currentPage.value = nextPage
                    _loadedAmiibos.value = _loadedAmiibos.value + newItems
                    _hasMorePages.value = repository.hasMorePages(nextPage, _pageSize.value)

                    _uiState.value = AmiiboUiState.Success(
                        amiibos = _loadedAmiibos.value,
                        isRefreshing = false
                    )
                } else {
                    _hasMorePages.value = false
                }
            } catch (e: Exception) {
                _paginationError.value = e.message ?: "Error al cargar m√°s items"
            } finally {
                _isLoadingMore.value = false
            }
        }
    }

    fun retryLoadMore() {
        _paginationError.value = null
        loadNextPage()
    }

    fun refreshAmiibos() {
        viewModelScope.launch {
            val currentAmiibos = _loadedAmiibos.value
            if (currentAmiibos.isEmpty()) {
                _uiState.value = AmiiboUiState.Loading
            } else {
                _uiState.value = AmiiboUiState.Success(
                    amiibos = currentAmiibos,
                    isRefreshing = true
                )
            }

            try {
                repository.refreshAmiibos()

                resetPagination()
                val firstPageItems = repository.getAmiibosPage(0, _pageSize.value)
                _loadedAmiibos.value = firstPageItems
                _hasMorePages.value = repository.hasMorePages(0, _pageSize.value)

                _uiState.value = AmiiboUiState.Success(
                    amiibos = firstPageItems,
                    isRefreshing = false
                )

            } catch (e: AmiiboError) {
                /**
                 * MANEJO DE ERRORES TIPADOS
                 * -------------------------
                 * Capturamos AmiiboError (sealed class) para proporcionar:
                 * 1. Mensajes espec√≠ficos por tipo de error
                 * 2. Indicar si se puede reintentar
                 * 3. Tipo de error para que la UI muestre iconos apropiados
                 *
                 * Esto mejora la UX porque el usuario sabe:
                 * - Si es su conexi√≥n (Network) ‚Üí revisar WiFi/datos
                 * - Si es del servidor (Parse) ‚Üí esperar y reintentar despu√©s
                 * - Si es local (Database) ‚Üí reiniciar app o liberar espacio
                 */
                val cachedAmiibos = _loadedAmiibos.value
                val errorType = ErrorType.from(e)

                val isRetryable = when (e) {
                    is AmiiboError.Network -> true
                    is AmiiboError.Parse -> false
                    is AmiiboError.Database -> true
                    is AmiiboError.Unknown -> true
                }

                // üî• L√ìGICA OFFLINE-FIRST ELEGANTE
                if (cachedAmiibos.isEmpty()) {
                    // Sin cache ‚Üí error pantalla completa
                    _uiState.value = AmiiboUiState.Error(
                        message = e.message,
                        errorType = errorType,
                        isRetryable = isRetryable,
                        cachedAmiibos = emptyList()
                    )
                } else {
                    // Con cache ‚Üí se conservan los datos + snackbar
                    _uiState.value = AmiiboUiState.Error(
                        message = "Error de red. Mostrando datos en cach√©.",
                        errorType = errorType,
                        isRetryable = true,
                        cachedAmiibos = cachedAmiibos
                    )
                }
            } catch (e: Exception) {
                val cachedAmiibos = _loadedAmiibos.value
                _uiState.value = AmiiboUiState.Error(
                    message = e.message ?: "Error desconocido al cargar datos",
                    errorType = ErrorType.UNKNOWN,
                    isRetryable = true,
                    cachedAmiibos = cachedAmiibos
                )
            }
        }
    }
}
